# lists.py
# @author   Justin Noddell


import os
import requests
from random import randrange
import src.tastypackage.command_line_functions as CLI


# class IngredientList
# a list of ingredients generated by the user
#  - ingredients can be added or removed
#  - the list can be viewed at any time while configuring it
class IngredientList:

    # __init__
    # params:       None
    # returns:      None
    # purpose:      to construct the object and its class variables:
    #                   * __list:           tracks user-generated ingredients
    #                   * __invalid:        a hash set of invalid ingredients, giving O(1) time lookups
    #                   * __set:            a hash set of __list providing O(1) time lookups of ingredients
    #                   * __size:           the length of __list
    #                   * __stack:          a queue of recipes to display to the user
    #                   * __seen:           a list of recipe IDs the user has been shown
    #                   * __stack_multiplier:   the number of times the recipe stack has had to be filled 
    #                   * __multiplier_limit:   the number of times the stack multiplier may be upped

    def __init__(self):

        self.__list = list()
        self.__invalid = set()
        self.__set = set()
        self.__size = 0
        self.__stack = list()
        self.__seen = set()
        self.__stack_multiplier = 1
        self.__multiplier_limit = 32
    
    # __add_ingredient
    # params:       new_ingredient: str -> the new user-generated ingredient
    # returns:      None
    # purpose:      add an ingredient the list, mark it as invalid if needed
    def __add_ingredient(self, new_ingredient: str) -> None:

        # case: ingredient DNE within api (may be a typo): prompt confirmation
        if not self.exists(new_ingredient):
            if CLI.confirm("Did you mean to type '" + new_ingredient + "' ?"):

                self.__list.append(new_ingredient)
                self.__set.add(new_ingredient)
                self.__size += 1
                self.__invalid.add(new_ingredient)
                print(CLI.info_msg_id, new_ingredient, "has been added to the list.\n")
        
        # case: ingredient has been ID'd
        else:

            self.__list.append(new_ingredient)
            self.__set.add(new_ingredient)
            self.__size += 1
            print(CLI.info_msg_id, new_ingredient, "has been added to the list.\n")

    # __remove_ingredient
    # params:       None
    # returns:      None
    # purpose:      remove the most recently added ingredient from __list, __set
    def __remove_ingredient(self) -> None:

        if self.is_empty():
            print(CLI.info_msg_id, "The ingredient list is currently empty.\n")
            return

        previous = self.__list.pop()
        if self.__invalid and previous in self.__invalid:
            self.__invalid.remove(previous)
        self.__set.remove(previous)
        self.__size -= 1
        print(CLI.info_msg_id, previous, "has been removed from the list.\n")
        
    # __contains
    # params:       ingredient: str -> the ingredient being checked
    # returns:      True/False
    # purpose:      determine if an ingredient is already in the ingredient list
    def __contains(self, ingredient: str) -> bool:

        return ingredient in self.__set

    # is_empty
    # params:       None
    # returns:      True/False
    # purpose:      to provide info regarding if the list is empty or not
    def is_empty(self) -> bool:

        return self.__size == 0

    # has_valid
    # params:       None
    # returns:      True/False
    # purpose:      determine if there is at least one valid ingredient in the list
    def has_valid(self) -> bool:

        return len(self.__invalid) < len(self.__list)
    
    # exists
    # params:       ingredient: str -> a user-generated ingredient
    # returns:      True/False depending if the recipe is found in a recipe or not
    # purpose:      to determine if the ingredient exists in any recipes within the API
    def exists(self, ingredient: str) -> bool:

        return True if self.find_recipe( ingredient, 1 ) else False
    
    # create
    # params:       None
    # returns:      None
    # purpose:      to create the list of user-requested ingredients
    def create(self) -> None:
        
        while True:

            # prompt for new ingredient; convert to string, then to lowercase to standardize input
            user_input = input("Enter a new ingredient:\n" + CLI.user_input_id)
            user_input = str(user_input).lower()
            print()

            if user_input == "done":
                # bypass an empty list, that check comes from main
                if self.is_empty():
                    return

                self.print_ingredients()
                if CLI.confirm("Are you done entering ingredients?"):
                    return

            elif user_input == "remove":

                self.__remove_ingredient()

            elif user_input == "help":

                self.print_guide()
            
            elif user_input == "view":

                self.print_ingredients()
            
            elif self.__contains(user_input):
                
                print(CLI.info_msg_id, user_input, "is already included.\n")
            
            else:

                self.__add_ingredient(user_input)
    
    # __format_get_recipe_by_ingredients
    # params:       endpoint: str -> base url of endpoint
    #               params: list -> parameters of get request
    # returns:      str -> adjusted url with params and api token
    # purpose:      create GET request url including api key and params for Search-Recipes-By-Ingredients
    def __format_get_recipe_by_ingredients(self, endpoint, params = list()) -> str:
        
        # ref. https://spoonacular.com/food-api/docs#Search-Recipes-by-Ingredients
        url = endpoint
        api_key = os.environ['API_KEY']
        url += "?apiKey=" + api_key

        N = len(params)
        if N:

            url += "&"
            i = 0
            for i, k in enumerate(params):

                url += k + "=" + str(params[k])
                if i < N - 1:
                    url += "&"

        return url

    # ___generate_recipes
    # params:       None
    # returns:      None
    # purpose:      create a stack of recipes to display to user, avoid recipes already displayed
    def ___generate_recipes(self) -> None:

        # cap num of recipes retrived to minimize API calls
        MAX_NUM_RECIPES = int(20 * self.__stack_multiplier)
        new_recipes = self.find_recipe(self.__list, MAX_NUM_RECIPES)

        if new_recipes:
            self.__stack += new_recipes
            
        # Remove recipes that have been seen before
        used_recipes = []
        N = len(self.__stack)
        for i in range(N):
            
            recipe = self.__stack[i]
            if recipe["id"] in self.__seen:
                used_recipes.append(i)
        
        # remove recipes
        for i in reversed(range(len(used_recipes))):

            del self.__stack[used_recipes[i]]

    # get_recipe
    # params:       ingredient: list -> an ingredient to use        
    # returns:      list -> an array of ingredients to use
    # purpose:      select a recipe from __stack to display to the user
    def get_recipe(self, ingredient: list = list()) -> list:
  
        # case: there are no valid ingredients in ingredient list
        if not self.has_valid():

            return []   # CLI feedback comes from main
        
        # case: there are no recipes that can be found, search has reached its limit
        elif not self.__stack and self.__stack_multiplier > self.__multiplier_limit:

            CLI.recipes_exhausted()
            return []

        # case: queue needs to generate more recipes
        elif not self.__stack:

            print(CLI.info_msg_id, "Generating recipes...\n")
            self.___generate_recipes()
            self.__stack_multiplier *= 2
            return self.get_recipe(ingredient)

        # randomly select, mark, remove, and return a recipe from the stack
        index = randrange(len(self.__stack))
        recipe = self.__stack[index]

        self.__seen.add(recipe["id"])
        del self.__stack[index]
        
        return recipe
    
    # find_recipe
    # params:       ingredient: list -> an ingredient to use   
    #               num_recipes: int -> max number of recipes to return
    # returns:      list -> an array of ingredients to use
    # purpose:      attempt to create a list of at least one recipe from the given ingredients list
    def find_recipe(self, ingredients: list = list(), num_recipes: int = 1) -> list:

        # prepare for possibility of no/loss of internet connection 
        try:
            # ref. https://spoonacular.com/food-api/docs#Search-Recipes-by-Ingredients
            endpoint = "https://api.spoonacular.com/recipes/findByIngredients"

            if not ingredients:
                ingredients = self.__list

            PARAMS = {
                'ingredients': ingredients,             # a comma separated list of ingredients
                'number': num_recipes,                  # the max number of recipes returned
                'limitLicense': False,                  # Whether the recipes should have an open license that allows display with proper attribution.
                'ranking': 1,                           # Whether to maximize used ingredients (1) or minimize missing ingredients (2) first.
                'ignorePantry': False                   # Whether to ignore typical pantry items, such as water, salt, flour, etc.
            }

            URL = self.__format_get_recipe_by_ingredients(endpoint, PARAMS)
            
            # execute request
            r = requests.get(url = URL)
            results = r.json()
            
            try:
                # case: received error code back
                if "status" in results and results["status"] == "failure":

                    CLI.api_error()
                    return []
                
                # case: recipe found
                elif results:
                    
                    return results

            except Exception:

                pass

            return []
        
        except Exception:

            return []

    # get_ingredients
    # params:       None
    # returns:      list -> an array of ingredients
    # purpose:      return the current list of ingredients
    def get_ingredients(self) -> list:

        return self.__list

    # recipes_exhausted
    # params:       None
    # returns:      True/False
    # purpose:      is the recipe generation limit exhausted
    def recipes_exhausted(self) -> list:

        return self.__stack_multiplier > self.__multiplier_limit and not self.__stack
    
    # print_ingredients
    # params:       None
    # returns:      None
    # purpose:      print the ingredient list to the console
    def print_ingredients(self) -> None:

        if self.is_empty():

            print(CLI.info_msg_id, "There currently are no ingredients in the list.\n")
            
        else:

            print("Ingredients:")
            for ingredient in self.__list:

                # case: ingredient is invalid, to be marked
                if ingredient in self.__invalid:
                    
                    print("{:2s} {:1s} {:72s}".format(" *", "-", ingredient))
                
                # case: ingredient is valid
                else:

                    print("{:2s} {:1s} {:72s}".format("  ", "-", ingredient))
            
            if self.__invalid:

                print("\n* indicates this item was not found in any recipes")

            print()

    # print_guide
    # params:       None
    # returns:      None
    # purpose:      print the help message while user is generating the ingredient list
    def print_guide(self) -> None:

        print(CLI.info_msg_id, "Please enter your ingredients one at a time below.")
        print(CLI.info_msg_id, "Type 'done' when you are finished.")
        print(CLI.info_msg_id, "Type 'remove' to erase the most recently added ingredient.")
        print(CLI.info_msg_id, "Type 'view' to view the current ingredient list.")
        print(CLI.info_msg_id, "Type 'help' to view this message again.\n")



# class ShoppingList()
# a list of missing ingredients for recipes desired by the user. pertitent data: ingredient name, id, aisle, price
class ShoppingList():

    # __init__
    # params:       blacklist: list -> an exisiting list of ingredients to exclude from the shopping list
    # returns:      None
    # purpose:      to construct the object and its class variables:
    #                   * __shopping_list: a ditionary of missing ingredients [key] for recipes and their respective IDs, aisles, and prices [values]
    #                   * __blacklist: a list of ingredients to exclude from the shopping list
    #                   * __products: a list of recipe IDs to help determine pricing
    #                   * __total: the total cost of the shopping list
    def __init__(self, blacklist: list = list()):

        self.__shopping_list = dict()
        self.__blacklist = set(blacklist)
        self.__products = list()
        self.__total = 0

    # __add_ingredient
    # params:       new_ingredient: dict -> the new user-generated ingredient
    # returns:      None
    # purpose:      add a missing ingredient to the shopping list
    def __add_ingredient(self, new_ingredient: dict) -> None:

        # ref. https://spoonacular.com/food-api/docs#Get-Product-Information
        name = new_ingredient["name"]
        aisle = new_ingredient["aisle"]
        price = float(0.0)

        # case: user already has ingredient
        if name in self.__blacklist:
            return
        
        # case: ingredient does not exist in shopping list
        elif name not in self.__shopping_list:

            self.__shopping_list[name] = [aisle, price]

            # NOTE: ingredients may go by multiple names, (i.e. a derivative of an ingredient; e.g. ingredient list: cheese, recipe: brie; e.g. ingredient list: raspberry, recipe: frozen raspberries)
            # There is no way to tell which name the ingredient will be ID'd by in the pricing data we retrieve, so we must prepare for any name
            # At the end, we will remove data with missing values as those entries have been covered by another 'name'

            # case: product goes by alt name in price description
            if "extendedName" in new_ingredient and new_ingredient["extendedName"] not in self.__shopping_list:
                name = new_ingredient["extendedName"]
                self.__shopping_list[name] = [aisle, price]
            
            # case: product goes by alt name in price description
            if "originalName" in new_ingredient and new_ingredient["originalName"] not in self.__shopping_list:
                name = new_ingredient["originalName"]
                self.__shopping_list[name] = [aisle, price]

    # add_recipe
    # params:       recipe: dict -> a recipe from the spoonacular API
    # returns:      True/False: was recipe successfully added
    # purpose:      add a recipe to the shopping list, and all the data it requries
    def add_recipe(self, recipe: dict) -> bool:

        if not recipe:
            return False
            
        self.__products.append(recipe["id"])
        for ingredient in recipe["missedIngredients"]:

            self.__add_ingredient(ingredient)

        # case: API cannot be reached
        if self.__get_cost(recipe) < 0:

            CLI.api_error()
            return False
        
        print(CLI.info_msg_id, recipe["title"], "has been added to the shopping list.\n")
        return True

    # __get_cost
    # params:       recipe: dict -> a recipe
    # returns:      int -> the cost of the recipe
    # purpose:      add the price of each ingredient in a recipe to the shopping list 'receipt'
    def __get_cost(self, recipe: dict) -> int:

        # protect against no/loss of internet connection
        try:
            # ref. https://spoonacular.com/food-api/docs#Price-Breakdown-by-ID
            rid = recipe["id"]
            api_key = os.environ['API_KEY']
            URL = "https://api.spoonacular.com/recipes/" + str(rid) + "/priceBreakdownWidget.json" + "?apiKey=" + api_key

            # execute request
            r = requests.get( url = URL )
            data = r.json()

            N = len(data["ingredients"])
            total_cost = 0
            for i in range(N):

                ingredient = data["ingredients"][i]
                name = ingredient["name"]
                price = ingredient["price"]

                # case: ingredient is blacklisted (user has it available)
                if name in self.__blacklist:

                    continue       

                # case: ingredient is marked, add price to total 
                elif name in self.__shopping_list:

                    self.__shopping_list[name][1] += price
                    total_cost += price
                
                # case: ingredient goes by different name, add new entry
                else:

                    self.__shopping_list[name] = ["???", price]
                    total_cost += price


            return total_cost
        
        except Exception:

            return -999.99

    # __calculate_bill
    # params:       None
    # returns:      None
    # purpose:      calculate grand total of ingredients in shopping list
    def __calculate_bill(self) -> None:

        self.__total = sum(self.__shopping_list[ingredient][1] for ingredient in self.__shopping_list)
        
    # __remove_empties
    # params:       None
    # returns:      None
    # purpose:      remove empty entries from shopping list
    def __remove_empties(self) -> None:

        unused = []
        for k in self.__shopping_list:

            aisle, price = self.__shopping_list[k]
            if price == 0 or aisle == "???":
                unused.append(k)
        
        for k in unused:

            del self.__shopping_list[k]
        
    # cleanup
    # params:       None
    # returns:      None
    # purpose:      finalize the aisles, total cost of list
    def cleanup(self) -> None:

        self.__remove_empties()

        self.__calculate_bill()

    # print_recipe
    # params:       recipe: dict -> a recipe from the spoonacular API
    # returns:      None
    # purpose:      print the details of a suggested recipe
    def print_recipe(self, recipe: dict) -> None:

        # get used ingredients
        u_ingredients = ""
        N = len(recipe["usedIngredients"])
        for i in range(N):
            u_ingredients += recipe["usedIngredients"][i]["name"]
            if i < N - 1:
                u_ingredients += ", "

        # get missing ingredients
        m_ingredients = ""
        N = len(recipe["missedIngredients"])
        for i in range(N):
            m_ingredients += recipe["missedIngredients"][i]["name"]
            if i < N - 1:
                m_ingredients += ", "

        print("Recipe:\n")
        print(recipe["title"])
        char_count = sum(len(ing) for ing in u_ingredients)
        end_symbol = "" if char_count < 75 else "..."
        print("{:25.25} {:75.75} {:3}".format(CLI.list_id + "Uses:", u_ingredients, end_symbol))
        char_count = sum(len(ing) for ing in m_ingredients)
        end_symbol = "" if char_count < 75 else "..."
        print("{:25.25} {:75.75} {:3}".format(CLI.list_id + "Missing Ingredients:", m_ingredients, end_symbol))
        end_symbol = "" if len(recipe["image"]) < 75 else "..."
        print("{:25.25} {:75.75} {:3}".format(CLI.list_id + "Image Link:", recipe["image"], end_symbol))

    #print_basic
    # params:       None
    # returns:      None
    # purpose:      print a simplified version of the shopping list
    def print_basic(self) -> None:

        # case: there exists a shopping list
        if self.__shopping_list:

            print("Shopping List Ingredients:\n")
            for ingredient in sorted(self.__shopping_list, key=lambda item: item):
                print("{:3} {:72.72s}".format(CLI.list_id, ingredient))
        
        # case: there does not exist a shopping list
        else:
            
            print("Your shopping list is empty!")

    # print_detailed
    # params:       None
    # returns:      None
    # purpose:      print the ingredient list with all available information
    def print_detailed(self) -> None:

        # case: there exists a shopping list
        if self.__shopping_list:

            top_border = "*" * 77
            partial_border = "*" * 31
            print(top_border)
            print(partial_border, "Shopping List", partial_border)
            print(top_border + "\n")

            print("{:30s} {:30s} {:15s}\n".format("Item", "Aisle", "Est. Price"))

            for ingredient, data in sorted(self.__shopping_list.items(), key=lambda item: item[1]):

                aisle = data[0]
                price = data[1]
                print("{:30.30s} {:30.30s} {:15.2f}".format(ingredient, aisle, price))
            
            print("\n{:45s} {:15s} {:15.2f}".format("", "Est. Total", self.__total))
        
        # case: there does not exist a shopping list
        else:
            
            print("Your shopping list is empty!")